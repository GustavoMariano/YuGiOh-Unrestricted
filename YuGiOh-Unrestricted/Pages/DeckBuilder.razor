@page "/deckbuilder/{DeckId:guid}"
@inject IDeckService DecksSvc
@inject ICardService CardsSvc
@inject NavigationManager Nav

@using Microsoft.AspNetCore.WebUtilities
@using YuGiOh_Unrestricted.Core.Models
@using YuGiOh_Unrestricted.Core.Models.Enums
@using YuGiOh_Unrestricted.Core.Services

<h3>Deck Builder</h3>

@if (deck is null)
{
    <p>Loading...</p>
}
else
{
    <h4>Deck: @deck.Name</h4>

    <h4>Cards in Deck (@deck.Cards.Sum(c => c.Count))/50</h4>

    <div style="display:flex; flex-wrap:wrap; gap:16px;">
        @if (deck.Cards.Any())
        {
            @foreach (var dc in deck.Cards)
            {
                <div style="border:1px solid #555; padding:8px; width:200px; text-align:center;">
                    <img src="@dc.Card.ImageUrl" alt="@dc.Card.Name" style="width:100%; height:auto;" />
                    <div style="margin-top:6px;"><strong>@dc.Card.Name</strong> <span>× @dc.Count</span></div>

                    <div style="display:flex; gap:8px; justify-content:center; margin-top:8px;">
                        <a class="btn"
                           href="@BuildActionUrl("add", dc.Card.Id)"
                           style="pointer-events:@(dc.Count >= DeckRules.MaxCopiesPerCard ? "none" : "auto");
                                              opacity:@(dc.Count >= DeckRules.MaxCopiesPerCard ? "0.5" : "1");">
                            + copy
                        </a>

                        <a class="btn" href="@BuildActionUrl("remove", dc.Card.Id)">- remove</a>
                    </div>
                </div>
            }
        }
        else
        {
            <p>No cards in this deck yet.</p>
        }
    </div>

    <hr />

    <h4>Add Cards</h4>

    <form method="get" action="@($"/deckbuilder/{DeckId}")" style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
        <select name="type" value="@filterTypeText" style="min-width:120px;">
            <option value="">All</option>
            <option value="Monster">Monster</option>
            <option value="Spell">Spell</option>
            <option value="Trap">Trap</option>
        </select>

        <input name="q" value="@searchTerm" placeholder="Name contains..." />

        <button type="submit">Search</button>
        <input type="hidden" name="keep" value="1" />
    </form>

    @if (results is null)
    {
        <p style="color:gray; margin-top:6px;">No search performed yet.</p>
    }
    else if (results.Count == 0)
    {
        <p style="color:tomato; margin-top:6px;">No cards found.</p>
    }
    else
    {
        <h5 style="margin-top:14px;">Search Results</h5>
        <div style="display:flex; flex-wrap:wrap; gap:16px; margin-top:10px;">
            @foreach (var c in results)
            {
                <div style="border:1px solid #555; padding:8px; width:200px; text-align:center;">
                    <img src="@c.ImageUrl" alt="@c.Name" style="width:100%; height:auto;" />
                    <div style="margin-top:6px;"><strong>@c.Name</strong></div>

                    <div style="margin-top:8px;">
                        <a class="btn"
                           href="@BuildActionUrl("add", c.Id)"
                           style="pointer-events:@(deck.Cards.Sum(x => x.Count) >= DeckRules.MaxCards ? "none" : "auto");
                                              opacity:@(deck.Cards.Sum(x => x.Count) >= DeckRules.MaxCards ? "0.5" : "1");">
                            Add
                        </a>
                    </div>
                </div>
            }
        </div>
    }
}

@code {
    [Parameter] public Guid DeckId { get; set; }

    private Deck? deck;
    private string filterTypeText = "";
    private string searchTerm = "";
    private List<Card>? results;

    protected override async Task OnParametersSetAsync()
    {
        deck = await DecksSvc.GetDeckAsync(DeckId);

        var uri = new Uri(Nav.Uri);
        var query = QueryHelpers.ParseQuery(uri.Query);

        if (query.TryGetValue("add", out var addStr) && Guid.TryParse(addStr, out var addId))
        {
            var ok = await DecksSvc.AddCopyAsync(DeckId, addId);
            deck = await DecksSvc.GetDeckAsync(DeckId);

            Nav.NavigateTo($"/deckbuilder/{DeckId}", replace: true);
            return;
        }

        if (query.TryGetValue("remove", out var remStr) && Guid.TryParse(remStr, out var remId))
        {
            await DecksSvc.RemoveCopyAsync(DeckId, remId);
            deck = await DecksSvc.GetDeckAsync(DeckId);

            Nav.NavigateTo($"/deckbuilder/{DeckId}", replace: true);
            return;
        }

        filterTypeText = query.TryGetValue("type", out var tVal) ? tVal.ToString() : "";
        searchTerm = query.TryGetValue("q", out var qVal) ? qVal.ToString() : "";

        if (query.ContainsKey("q") || query.ContainsKey("type"))
        {
            ECardType? t = null;
            if (!string.IsNullOrWhiteSpace(filterTypeText) &&
                Enum.TryParse<ECardType>(filterTypeText, out var parsed))
            {
                t = parsed;
            }

            results = await CardsSvc.SearchAsync(t, searchTerm);
        }
        else
        {
            results = null;
        }
    }

    private string BuildActionUrl(string action, Guid cardId)
        => $"/deckbuilder/{DeckId}?{action}={cardId}";
}
